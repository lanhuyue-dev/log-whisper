# LogWhisper 技术方案文档

## 1. 技术架构概述

### 1.1 整体架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                     LogWhisper 技术架构                      │
├─────────────────────────────────────────────────────────────┤
│  前端层 (Tauri WebView)                                      │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  HTML + CSS + JavaScript                               │ │
│  │  ├─ 双栏布局界面                                        │ │
│  │  ├─ 文件拖拽处理                                        │ │
│  │  ├─ 插件切换控制                                        │ │
│  │  └─ 用户交互响应                                        │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Tauri Bridge (IPC 通信层)                                  │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  invoke() 调用                                          │ │
│  │  ├─ 文件读取                                            │ │
│  │  ├─ 日志解析                                            │ │
│  │  ├─ 插件切换                                            │ │
│  │  └─ 结果返回                                            │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  后端层 (Rust Core)                                         │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  日志解析引擎                                           │ │
│  │  ├─ 文件读取模块                                        │ │
│  │  ├─ 插件化解析器                                        │ │
│  │  ├─ 结果渲染引擎                                        │ │
│  │  └─ 后台处理线程                                        │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术选型说明

| 技术栈 | 选择方案 | 理由 |
|--------|----------|------|
| **核心语言** | Rust | 内存安全、高性能、编译为原生可执行文件 |
| **桌面框架** | Tauri 1.6+ | 轻量级、安全性高、Rust优先、体积小 |
| **前端技术** | Vanilla HTML + JS + Tailwind CSS | 无需构建工具、代码简洁、快速开发 |
| **JSON处理** | serde_json | Rust官方推荐、高性能、类型安全 |
| **正则引擎** | regex crate | 高性能、Unicode支持、功能完整 |
| **时间解析** | chrono | 功能丰富、性能优秀、社区活跃 |
| **打包工具** | tauri build | 官方工具、支持多平台、配置简单 |

## 2. 核心模块设计

### 2.1 项目结构

```
log-whisper/
├── src/
│   ├── main.rs                 # 应用入口
│   ├── lib.rs                  # 库入口
│   ├── models/                 # 数据模型
│   │   ├── mod.rs
│   │   ├── log_entry.rs        # 日志条目模型
│   │   ├── rendered_block.rs   # 渲染块模型
│   │   └── plugin_config.rs    # 插件配置模型
│   ├── plugins/                # 插件系统
│   │   ├── mod.rs
│   │   ├── trait.rs            # LogRenderer trait定义
│   │   ├── mybatis.rs          # MyBatis解析插件
│   │   ├── json_repair.rs      # JSON修复插件
│   │   ├── error_highlighter.rs # 错误高亮插件
│   │   └── raw.rs              # 原始文本插件
│   ├── parser/                 # 解析引擎
│   │   ├── mod.rs
│   │   ├── log_parser.rs       # 主解析器
│   │   ├── file_reader.rs      # 文件读取器
│   │   └── renderer.rs         # 渲染引擎
│   ├── tauri/                  # Tauri集成
│   │   ├── mod.rs
│   │   ├── commands.rs         # Tauri命令定义
│   │   └── handlers.rs          # 事件处理器
│   └── utils/                  # 工具函数
│       ├── mod.rs
│       ├── file_utils.rs       # 文件操作工具
│       └── string_utils.rs     # 字符串处理工具
├── src-tauri/
│   ├── src/
│   │   └── main.rs             # Tauri后端入口
│   ├── Cargo.toml              # Rust依赖配置
│   └── tauri.conf.json         # Tauri配置文件
├── src/                        # 前端源码
│   ├── index.html              # 主页面
│   ├── style.css               # 样式文件
│   └── main.js                  # 前端逻辑
├── Cargo.toml                  # 项目配置
└── README.md                   # 项目说明
```

### 2.2 核心数据结构

#### 2.2.1 日志条目模型

```rust
// src/models/log_entry.rs
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    pub line_number: usize,
    pub timestamp: Option<DateTime<Utc>>,
    pub level: LogLevel,
    pub content: String,
    pub raw_line: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsedLogEntry {
    pub original: LogEntry,
    pub rendered_blocks: Vec<RenderedBlock>,
    pub is_error: bool,
    pub is_warning: bool,
}
```

#### 2.2.2 渲染块模型

```rust
// src/models/rendered_block.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderedBlock {
    pub id: String,
    pub block_type: BlockType,
    pub title: String,
    pub content: String,
    pub formatted_content: String,
    pub is_copyable: bool,
    pub metadata: BlockMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BlockType {
    Sql,
    Json,
    Error,
    Warning,
    Info,
    Raw,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub line_start: usize,
    pub line_end: usize,
    pub char_start: usize,
    pub char_end: usize,
    pub confidence: f32, // 0.0 - 1.0
}
```

### 2.3 插件系统设计

#### 2.3.1 插件Trait定义

```rust
// src/plugins/trait.rs
use crate::models::{LogEntry, RenderedBlock};

pub trait LogRenderer: Send + Sync {
    /// 检查是否可以处理该日志条目
    fn can_handle(&self, entry: &LogEntry) -> bool;
    
    /// 处理日志条目，返回渲染块
    fn render(&self, entry: &LogEntry) -> Vec<RenderedBlock>;
    
    /// 获取插件名称
    fn name(&self) -> &str;
    
    /// 获取插件描述
    fn description(&self) -> &str;
    
    /// 获取插件优先级（数字越小优先级越高）
    fn priority(&self) -> u32;
}
```

#### 2.3.2 MyBatis插件实现

```rust
// src/plugins/mybatis.rs
use regex::Regex;
use crate::plugins::trait::LogRenderer;
use crate::models::{LogEntry, RenderedBlock, BlockType, BlockMetadata};

pub struct MyBatisRenderer {
    preparing_regex: Regex,
    parameters_regex: Regex,
    state: MyBatisState,
}

struct MyBatisState {
    current_sql: Option<String>,
    current_params: Option<Vec<String>>,
}

impl LogRenderer for MyBatisRenderer {
    fn can_handle(&self, entry: &LogEntry) -> bool {
        self.preparing_regex.is_match(&entry.content) || 
        self.parameters_regex.is_match(&entry.content)
    }
    
    fn render(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        if self.preparing_regex.is_match(&entry.content) {
            self.handle_preparing(entry)
        } else if self.parameters_regex.is_match(&entry.content) {
            self.handle_parameters(entry)
        } else {
            vec![]
        }
    }
    
    fn name(&self) -> &str {
        "MyBatis SQL Parser"
    }
    
    fn description(&self) -> &str {
        "解析MyBatis日志中的SQL语句和参数"
    }
    
    fn priority(&self) -> u32 {
        10
    }
}

impl MyBatisRenderer {
    fn handle_preparing(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        // 提取SQL语句
        if let Some(captures) = self.preparing_regex.captures(&entry.content) {
            if let Some(sql) = captures.get(1) {
                return vec![RenderedBlock {
                    id: format!("sql_{}", entry.line_number),
                    block_type: BlockType::Sql,
                    title: "SQL 查询".to_string(),
                    content: sql.as_str().to_string(),
                    formatted_content: self.format_sql(sql.as_str()),
                    is_copyable: true,
                    metadata: BlockMetadata {
                        line_start: entry.line_number,
                        line_end: entry.line_number,
                        char_start: 0,
                        char_end: entry.content.len(),
                        confidence: 0.9,
                    },
                }];
            }
        }
        vec![]
    }
    
    fn handle_parameters(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        // 处理参数并合并SQL
        if let Some(captures) = self.parameters_regex.captures(&entry.content) {
            if let Some(params) = captures.get(1) {
                return vec![RenderedBlock {
                    id: format!("params_{}", entry.line_number),
                    block_type: BlockType::Sql,
                    title: "SQL 参数".to_string(),
                    content: params.as_str().to_string(),
                    formatted_content: self.format_parameters(params.as_str()),
                    is_copyable: true,
                    metadata: BlockMetadata {
                        line_start: entry.line_number,
                        line_end: entry.line_number,
                        char_start: 0,
                        char_end: entry.content.len(),
                        confidence: 0.8,
                    },
                }];
            }
        }
        vec![]
    }
    
    fn format_sql(&self, sql: &str) -> String {
        // SQL格式化逻辑
        sql.to_string()
    }
    
    fn format_parameters(&self, params: &str) -> String {
        // 参数格式化逻辑
        params.to_string()
    }
}
```

#### 2.3.3 JSON修复插件实现

```rust
// src/plugins/json_repair.rs
use serde_json::Value;
use crate::plugins::trait::LogRenderer;
use crate::models::{LogEntry, RenderedBlock, BlockType, BlockMetadata};

pub struct JsonRepairRenderer {
    json_regex: Regex,
}

impl LogRenderer for JsonRepairRenderer {
    fn can_handle(&self, entry: &LogEntry) -> bool {
        self.json_regex.is_match(&entry.content)
    }
    
    fn render(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        if let Some(json_str) = self.extract_json(&entry.content) {
            if let Ok(repaired_json) = self.repair_json(json_str) {
                return vec![RenderedBlock {
                    id: format!("json_{}", entry.line_number),
                    block_type: BlockType::Json,
                    title: "JSON 数据".to_string(),
                    content: json_str.to_string(),
                    formatted_content: self.format_json(&repaired_json),
                    is_copyable: true,
                    metadata: BlockMetadata {
                        line_start: entry.line_number,
                        line_end: entry.line_number,
                        char_start: 0,
                        char_end: entry.content.len(),
                        confidence: 0.7,
                    },
                }];
            }
        }
        vec![]
    }
    
    fn name(&self) -> &str {
        "JSON Repair"
    }
    
    fn description(&self) -> &str {
        "修复和格式化JSON数据"
    }
    
    fn priority(&self) -> u32 {
        20
    }
}

impl JsonRepairRenderer {
    fn extract_json(&self, content: &str) -> Option<&str> {
        // 提取JSON字符串的逻辑
        self.json_regex.find(content).map(|m| m.as_str())
    }
    
    fn repair_json(&self, json_str: &str) -> Result<Value, serde_json::Error> {
        // JSON修复逻辑
        let repaired = self.fix_common_issues(json_str);
        serde_json::from_str(&repaired)
    }
    
    fn fix_common_issues(&self, json_str: &str) -> String {
        let mut result = json_str.to_string();
        
        // 修复缺少逗号
        result = result.replace(r#"}{"#, r#"},{""#);
        
        // 修复缺少引号
        result = self.fix_missing_quotes(&result);
        
        // 修复未闭合括号
        result = self.fix_unclosed_brackets(&result);
        
        result
    }
    
    fn fix_missing_quotes(&self, json_str: &str) -> String {
        // 实现引号修复逻辑
        json_str.to_string()
    }
    
    fn fix_unclosed_brackets(&self, json_str: &str) -> String {
        // 实现括号修复逻辑
        json_str.to_string()
    }
    
    fn format_json(&self, value: &Value) -> String {
        serde_json::to_string_pretty(value).unwrap_or_default()
    }
}
```

### 2.4 解析引擎设计

#### 2.4.1 主解析器

```rust
// src/parser/log_parser.rs
use std::sync::Arc;
use tokio::task;
use crate::models::{LogEntry, ParsedLogEntry};
use crate::plugins::trait::LogRenderer;
use crate::parser::file_reader::FileReader;
use crate::parser::renderer::Renderer;

pub struct LogParser {
    renderers: Vec<Arc<dyn LogRenderer>>,
    file_reader: FileReader,
    renderer: Renderer,
}

impl LogParser {
    pub fn new() -> Self {
        let renderers = Self::create_renderers();
        let file_reader = FileReader::new();
        let renderer = Renderer::new(renderers.clone());
        
        Self {
            renderers,
            file_reader,
            renderer,
        }
    }
    
    pub async fn parse_file(&self, file_path: &str) -> Result<Vec<ParsedLogEntry>, ParserError> {
        // 异步读取文件
        let lines = self.file_reader.read_lines(file_path).await?;
        
        // 解析日志条目
        let log_entries = self.parse_lines(lines).await?;
        
        // 渲染结果
        let parsed_entries = self.renderer.render_entries(log_entries).await?;
        
        Ok(parsed_entries)
    }
    
    async fn parse_lines(&self, lines: Vec<String>) -> Result<Vec<LogEntry>, ParserError> {
        let mut entries = Vec::new();
        
        for (index, line) in lines.iter().enumerate() {
            let entry = self.parse_line(index + 1, line)?;
            entries.push(entry);
        }
        
        Ok(entries)
    }
    
    fn parse_line(&self, line_number: usize, line: &str) -> Result<LogEntry, ParserError> {
        // 解析时间戳
        let timestamp = self.extract_timestamp(line);
        
        // 解析日志级别
        let level = self.extract_log_level(line);
        
        // 提取内容
        let content = self.extract_content(line);
        
        Ok(LogEntry {
            line_number,
            timestamp,
            level,
            content,
            raw_line: line.to_string(),
        })
    }
    
    fn create_renderers() -> Vec<Arc<dyn LogRenderer>> {
        vec![
            Arc::new(MyBatisRenderer::new()),
            Arc::new(JsonRepairRenderer::new()),
            Arc::new(ErrorHighlighterRenderer::new()),
            Arc::new(RawRenderer::new()),
        ]
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ParserError {
    #[error("文件读取错误: {0}")]
    FileReadError(String),
    
    #[error("解析错误: {0}")]
    ParseError(String),
    
    #[error("渲染错误: {0}")]
    RenderError(String),
}
```

#### 2.4.2 渲染引擎

```rust
// src/parser/renderer.rs
use std::sync::Arc;
use crate::models::{LogEntry, ParsedLogEntry, RenderedBlock};
use crate::plugins::trait::LogRenderer;

pub struct Renderer {
    renderers: Vec<Arc<dyn LogRenderer>>,
}

impl Renderer {
    pub fn new(renderers: Vec<Arc<dyn LogRenderer>>) -> Self {
        Self { renderers }
    }
    
    pub async fn render_entries(&self, entries: Vec<LogEntry>) -> Result<Vec<ParsedLogEntry>, RenderError> {
        let mut parsed_entries = Vec::new();
        
        for entry in entries {
            let rendered_blocks = self.render_entry(&entry).await?;
            let is_error = self.is_error_entry(&entry);
            let is_warning = self.is_warning_entry(&entry);
            
            parsed_entries.push(ParsedLogEntry {
                original: entry,
                rendered_blocks,
                is_error,
                is_warning,
            });
        }
        
        Ok(parsed_entries)
    }
    
    async fn render_entry(&self, entry: &LogEntry) -> Result<Vec<RenderedBlock>, RenderError> {
        let mut all_blocks = Vec::new();
        
        // 按优先级排序渲染器
        let mut sorted_renderers = self.renderers.clone();
        sorted_renderers.sort_by_key(|r| r.priority());
        
        for renderer in sorted_renderers {
            if renderer.can_handle(entry) {
                let blocks = renderer.render(entry);
                all_blocks.extend(blocks);
            }
        }
        
        // 如果没有渲染器处理，使用原始文本
        if all_blocks.is_empty() {
            all_blocks.push(RenderedBlock {
                id: format!("raw_{}", entry.line_number),
                block_type: BlockType::Raw,
                title: "原始文本".to_string(),
                content: entry.content.clone(),
                formatted_content: entry.content.clone(),
                is_copyable: true,
                metadata: BlockMetadata {
                    line_start: entry.line_number,
                    line_end: entry.line_number,
                    char_start: 0,
                    char_end: entry.content.len(),
                    confidence: 1.0,
                },
            });
        }
        
        Ok(all_blocks)
    }
    
    fn is_error_entry(&self, entry: &LogEntry) -> bool {
        entry.level == LogLevel::Error || 
        entry.content.to_lowercase().contains("error") ||
        entry.content.to_lowercase().contains("exception")
    }
    
    fn is_warning_entry(&self, entry: &LogEntry) -> bool {
        entry.level == LogLevel::Warn || 
        entry.content.to_lowercase().contains("warn")
    }
}

#[derive(Debug, thiserror::Error)]
pub enum RenderError {
    #[error("渲染失败: {0}")]
    RenderFailed(String),
}
```

## 3. Tauri集成设计

### 3.1 Tauri命令定义

```rust
// src/tauri/commands.rs
use tauri::State;
use serde::{Deserialize, Serialize};
use crate::parser::log_parser::LogParser;
use crate::models::ParsedLogEntry;

#[derive(Debug, Serialize, Deserialize)]
pub struct ParseFileRequest {
    pub file_path: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ParseFileResponse {
    pub success: bool,
    pub entries: Vec<ParsedLogEntry>,
    pub error: Option<String>,
}

#[tauri::command]
pub async fn parse_file(
    request: ParseFileRequest,
    parser: State<'_, LogParser>,
) -> Result<ParseFileResponse, String> {
    match parser.parse_file(&request.file_path).await {
        Ok(entries) => Ok(ParseFileResponse {
            success: true,
            entries,
            error: None,
        }),
        Err(e) => Ok(ParseFileResponse {
            success: false,
            entries: vec![],
            error: Some(e.to_string()),
        }),
    }
}

#[tauri::command]
pub async fn get_supported_formats() -> Vec<String> {
    vec![".log".to_string(), ".txt".to_string()]
}

#[tauri::command]
pub async fn get_available_plugins() -> Vec<String> {
    vec![
        "Auto".to_string(),
        "MyBatis".to_string(),
        "JSON".to_string(),
        "Raw".to_string(),
    ]
}
```

### 3.2 前端集成

#### 3.2.1 HTML结构

```html
<!-- src/index.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogWhisper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body class="bg-gray-50">
    <div id="app" class="h-screen flex flex-col">
        <!-- 顶部工具栏 -->
        <div class="bg-white shadow-sm border-b p-4">
            <div class="flex items-center space-x-4">
                <button id="openFileBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                    选择文件
                </button>
                <div class="flex-1">
                    <input type="file" id="fileInput" accept=".log,.txt" class="hidden">
                </div>
                <select id="pluginSelect" class="border rounded px-3 py-2">
                    <option value="auto">Auto</option>
                    <option value="mybatis">MyBatis</option>
                    <option value="json">JSON</option>
                    <option value="raw">Raw</option>
                </select>
                <input type="text" id="searchInput" placeholder="搜索日志..." 
                       class="border rounded px-3 py-2 w-64">
            </div>
        </div>
        
        <!-- 主内容区域 -->
        <div class="flex-1 flex">
            <!-- 左侧：原始日志 -->
            <div class="w-1/2 border-r bg-white">
                <div class="p-4 border-b bg-gray-50">
                    <h3 class="font-semibold">原始日志</h3>
                </div>
                <div id="originalLog" class="p-4 font-mono text-sm overflow-auto h-full">
                    <div class="text-gray-500 text-center py-8">
                        拖拽日志文件到此处或点击"选择文件"
                    </div>
                </div>
            </div>
            
            <!-- 右侧：解析结果 -->
            <div class="w-1/2 bg-white">
                <div class="p-4 border-b bg-gray-50">
                    <h3 class="font-semibold">解析结果</h3>
                </div>
                <div id="parsedLog" class="p-4 overflow-auto h-full">
                    <div class="text-gray-500 text-center py-8">
                        选择文件后将显示解析结果
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 底部状态栏 -->
        <div class="bg-gray-100 border-t px-4 py-2 text-sm text-gray-600">
            <span id="statusText">就绪</span>
        </div>
    </div>
    
    <script src="main.js"></script>
</body>
</html>
```

#### 3.2.2 JavaScript逻辑

```javascript
// src/main.js
const { invoke } = window.__TAURI__.tauri;

class LogWhisperApp {
    constructor() {
        this.currentFile = null;
        this.currentEntries = [];
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.setupDragAndDrop();
    }
    
    setupEventListeners() {
        // 文件选择
        document.getElementById('openFileBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleFile(e.target.files[0]);
            }
        });
        
        // 插件切换
        document.getElementById('pluginSelect').addEventListener('change', (e) => {
            this.switchPlugin(e.target.value);
        });
        
        // 搜索过滤
        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.filterLogs(e.target.value);
        });
    }
    
    setupDragAndDrop() {
        const app = document.getElementById('app');
        
        app.addEventListener('dragover', (e) => {
            e.preventDefault();
            app.classList.add('bg-blue-50');
        });
        
        app.addEventListener('dragleave', (e) => {
            e.preventDefault();
            app.classList.remove('bg-blue-50');
        });
        
        app.addEventListener('drop', (e) => {
            e.preventDefault();
            app.classList.remove('bg-blue-50');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFile(files[0]);
            }
        });
    }
    
    async handleFile(file) {
        if (!this.isValidFile(file)) {
            this.showError('不支持的文件格式');
            return;
        }
        
        if (file.size > 50 * 1024 * 1024) {
            this.showError('文件过大，请使用专业工具');
            return;
        }
        
        this.showLoading('正在解析文件...');
        
        try {
            const response = await invoke('parse_file', {
                request: {
                    filePath: file.path
                }
            });
            
            if (response.success) {
                this.currentFile = file;
                this.currentEntries = response.entries;
                this.renderResults();
                this.updateStatus(`已加载 ${response.entries.length} 行日志`);
            } else {
                this.showError(response.error || '解析失败');
            }
        } catch (error) {
            this.showError(`解析错误: ${error}`);
        }
    }
    
    isValidFile(file) {
        const validExtensions = ['.log', '.txt'];
        const fileName = file.name.toLowerCase();
        return validExtensions.some(ext => fileName.endsWith(ext));
    }
    
    renderResults() {
        this.renderOriginalLog();
        this.renderParsedLog();
    }
    
    renderOriginalLog() {
        const container = document.getElementById('originalLog');
        container.innerHTML = '';
        
        this.currentEntries.forEach(entry => {
            const div = document.createElement('div');
            div.className = `p-2 border-b ${this.getLogLevelClass(entry.original.level)}`;
            div.innerHTML = `
                <div class="text-xs text-gray-500">${entry.original.line_number}</div>
                <div class="font-mono">${this.escapeHtml(entry.original.content)}</div>
            `;
            container.appendChild(div);
        });
    }
    
    renderParsedLog() {
        const container = document.getElementById('parsedLog');
        container.innerHTML = '';
        
        this.currentEntries.forEach(entry => {
            if (entry.rendered_blocks.length === 0) return;
            
            const div = document.createElement('div');
            div.className = `p-4 border-b ${entry.is_error ? 'bg-red-50' : entry.is_warning ? 'bg-yellow-50' : ''}`;
            
            let html = `<div class="text-xs text-gray-500 mb-2">第 ${entry.original.line_number} 行</div>`;
            
            entry.rendered_blocks.forEach(block => {
                html += this.renderBlock(block);
            });
            
            div.innerHTML = html;
            container.appendChild(div);
        });
    }
    
    renderBlock(block) {
        const blockClass = this.getBlockClass(block.block_type);
        const icon = this.getBlockIcon(block.block_type);
        
        return `
            <div class="mb-4 p-3 rounded border ${blockClass}">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center">
                        <span class="mr-2">${icon}</span>
                        <span class="font-semibold">${block.title}</span>
                    </div>
                    <button onclick="app.copyToClipboard('${block.id}')" 
                            class="text-blue-600 hover:text-blue-800 text-sm">
                        复制
                    </button>
                </div>
                <pre class="bg-gray-100 p-2 rounded text-sm overflow-x-auto">${this.escapeHtml(block.formatted_content)}</pre>
            </div>
        `;
    }
    
    getBlockClass(blockType) {
        const classes = {
            'Sql': 'border-green-200 bg-green-50',
            'Json': 'border-blue-200 bg-blue-50',
            'Error': 'border-red-200 bg-red-50',
            'Warning': 'border-yellow-200 bg-yellow-50',
            'Info': 'border-gray-200 bg-gray-50',
            'Raw': 'border-gray-200 bg-gray-50'
        };
        return classes[blockType] || classes['Raw'];
    }
    
    getBlockIcon(blockType) {
        const icons = {
            'Sql': '🔍',
            'Json': '📄',
            'Error': '⚠️',
            'Warning': '⚠️',
            'Info': 'ℹ️',
            'Raw': '📝'
        };
        return icons[blockType] || icons['Raw'];
    }
    
    getLogLevelClass(level) {
        const classes = {
            'Error': 'bg-red-50 border-l-4 border-red-500',
            'Warn': 'bg-yellow-50 border-l-4 border-yellow-500',
            'Info': 'bg-blue-50 border-l-4 border-blue-500',
            'Debug': 'bg-gray-50 border-l-4 border-gray-500'
        };
        return classes[level] || classes['Debug'];
    }
    
    async copyToClipboard(blockId) {
        // 实现复制到剪贴板功能
        const block = this.findBlockById(blockId);
        if (block) {
            await navigator.clipboard.writeText(block.formatted_content);
            this.showToast('已复制到剪贴板');
        }
    }
    
    findBlockById(blockId) {
        for (const entry of this.currentEntries) {
            for (const block of entry.rendered_blocks) {
                if (block.id === blockId) {
                    return block;
                }
            }
        }
        return null;
    }
    
    switchPlugin(pluginName) {
        // 实现插件切换逻辑
        console.log('切换插件:', pluginName);
    }
    
    filterLogs(searchTerm) {
        // 实现搜索过滤逻辑
        console.log('搜索:', searchTerm);
    }
    
    showLoading(message) {
        this.updateStatus(message);
    }
    
    showError(message) {
        this.updateStatus(`错误: ${message}`);
    }
    
    showToast(message) {
        // 实现Toast提示
        console.log(message);
    }
    
    updateStatus(message) {
        document.getElementById('statusText').textContent = message;
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// 初始化应用
const app = new LogWhisperApp();
```

## 4. 性能优化策略

### 4.1 内存管理

```rust
// 流式处理大文件
pub struct StreamingLogParser {
    chunk_size: usize,
    buffer: Vec<u8>,
}

impl StreamingLogParser {
    pub async fn parse_large_file(&mut self, file_path: &str) -> Result<(), ParserError> {
        let mut file = File::open(file_path).await?;
        let mut buffer = vec![0; self.chunk_size];
        
        loop {
            let bytes_read = file.read(&mut buffer).await?;
            if bytes_read == 0 {
                break;
            }
            
            // 处理当前块
            self.process_chunk(&buffer[..bytes_read]).await?;
        }
        
        Ok(())
    }
}
```

### 4.2 异步处理

```rust
// 后台解析任务
pub async fn parse_file_async(file_path: String) -> Result<Vec<ParsedLogEntry>, ParserError> {
    tokio::task::spawn_blocking(move || {
        // 在后台线程中执行CPU密集型任务
        let parser = LogParser::new();
        parser.parse_file_sync(&file_path)
    }).await?
}
```

### 4.3 缓存策略

```rust
// 解析结果缓存
use std::collections::HashMap;
use std::sync::RwLock;

pub struct ParseCache {
    cache: RwLock<HashMap<String, Vec<ParsedLogEntry>>>,
    max_size: usize,
}

impl ParseCache {
    pub fn get(&self, file_path: &str) -> Option<Vec<ParsedLogEntry>> {
        self.cache.read().unwrap().get(file_path).cloned()
    }
    
    pub fn set(&self, file_path: String, entries: Vec<ParsedLogEntry>) {
        let mut cache = self.cache.write().unwrap();
        if cache.len() >= self.max_size {
            // 简单的LRU策略
            cache.clear();
        }
        cache.insert(file_path, entries);
    }
}
```

## 5. 打包和分发

### 5.1 Tauri配置

```json
// src-tauri/tauri.conf.json
{
  "build": {
    "beforeDevCommand": "",
    "beforeBuildCommand": "",
    "devPath": "../src",
    "distDir": "../src"
  },
  "package": {
    "productName": "LogWhisper",
    "version": "1.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "fs": {
        "all": true,
        "readFile": true,
        "writeFile": true,
        "readDir": true,
        "copyFile": true,
        "createDir": true,
        "removeDir": true,
        "removeFile": true,
        "renameFile": true,
        "exists": true
      },
      "path": {
        "all": true
      },
      "dialog": {
        "all": true,
        "open": true,
        "save": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.logwhisper.app",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "LogWhisper",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600
      }
    ]
  }
}
```

### 5.2 构建脚本

```toml
# Cargo.toml
[package]
name = "log-whisper"
version = "1.0.0"
edition = "2021"

[dependencies]
tauri = { version = "1.6", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
regex = "1.0"
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
anyhow = "1.0"

[build-dependencies]
tauri-build = { version = "1.6", features = [] }
```

### 5.3 构建命令

```bash
# 开发模式
cargo tauri dev

# 生产构建
cargo tauri build

# 生成安装包
cargo tauri build --target x86_64-pc-windows-msvc
```

## 6. 测试策略

### 6.1 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_mybatis_parser() {
        let parser = MyBatisRenderer::new();
        let entry = LogEntry {
            line_number: 1,
            timestamp: None,
            level: LogLevel::Info,
            content: "Preparing: SELECT * FROM user WHERE id = ?".to_string(),
            raw_line: "Preparing: SELECT * FROM user WHERE id = ?".to_string(),
        };
        
        assert!(parser.can_handle(&entry));
        let blocks = parser.render(&entry);
        assert!(!blocks.is_empty());
        assert_eq!(blocks[0].block_type, BlockType::Sql);
    }
    
    #[test]
    fn test_json_repair() {
        let parser = JsonRepairRenderer::new();
        let entry = LogEntry {
            line_number: 1,
            timestamp: None,
            level: LogLevel::Info,
            content: r#"{"name":"张三","age":25}"#.to_string(),
            raw_line: r#"{"name":"张三","age":25}"#.to_string(),
        };
        
        assert!(parser.can_handle(&entry));
        let blocks = parser.render(&entry);
        assert!(!blocks.is_empty());
        assert_eq!(blocks[0].block_type, BlockType::Json);
    }
}
```

### 6.2 集成测试

```rust
#[tokio::test]
async fn test_full_parse_workflow() {
    let parser = LogParser::new();
    let test_file = "test_data/sample.log";
    
    let result = parser.parse_file(test_file).await;
    assert!(result.is_ok());
    
    let entries = result.unwrap();
    assert!(!entries.is_empty());
    
    // 验证解析结果
    for entry in entries {
        assert!(!entry.rendered_blocks.is_empty());
    }
}
```

## 7. 部署和发布

### 7.1 版本管理

```toml
# Cargo.toml
[package]
name = "log-whisper"
version = "1.0.0"
authors = ["Your Name <your.email@example.com>"]
description = "轻量级日志分析工具"
license = "MIT"
repository = "https://github.com/your-username/log-whisper"
```

### 7.2 发布流程

```bash
# 1. 更新版本号
cargo set-version 1.0.1

# 2. 运行测试
cargo test

# 3. 构建发布版本
cargo tauri build --target x86_64-pc-windows-msi

# 4. 生成发布说明
echo "## 更新内容" > CHANGELOG.md
echo "- 修复JSON解析问题" >> CHANGELOG.md
echo "- 优化性能" >> CHANGELOG.md

# 5. 创建Git标签
git tag v1.0.1
git push origin v1.0.1
```

---

**文档版本**：v1.0  
**创建日期**：2024年1月  
**最后更新**：2024年1月
