# LogWhisper 插件系统重构方案

## 1. 当前问题分析

### 1.1 现有架构的局限性
- **硬编码插件**：插件类型和逻辑直接写死在代码中
- **缺乏扩展性**：新增插件需要修改核心代码
- **配置不灵活**：插件参数和优先级无法动态配置
- **缺乏插件管理**：无法动态启用/禁用插件
- **缺乏插件发现**：无法自动发现和加载新插件

### 1.2 设计目标
- **高度可扩展**：支持动态加载和注册插件
- **配置驱动**：通过配置文件管理插件行为
- **插件隔离**：插件之间相互独立，互不影响
- **性能优化**：支持插件优先级和条件执行
- **易于开发**：提供清晰的插件开发接口

## 2. 新架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    LogWhisper 插件系统                      │
├─────────────────────────────────────────────────────────────┤
│  插件注册中心 (Plugin Registry)                              │
│  ├─ 插件发现机制                                            │
│  ├─ 插件生命周期管理                                        │
│  └─ 插件依赖解析                                            │
├─────────────────────────────────────────────────────────────┤
│  插件管理器 (Plugin Manager)                                │
│  ├─ 插件加载器                                              │
│  ├─ 插件执行器                                              │
│  └─ 插件配置管理                                            │
├─────────────────────────────────────────────────────────────┤
│  插件接口层 (Plugin Interface)                              │
│  ├─ LogParser (日志解析器)                                  │
│  ├─ LogRenderer (日志渲染器)                               │
│  ├─ LogFilter (日志过滤器)                                  │
│  └─ LogExporter (日志导出器)                                │
├─────────────────────────────────────────────────────────────┤
│  内置插件 (Built-in Plugins)                                │
│  ├─ MyBatisParser                                          │
│  ├─ JsonRepairRenderer                                     │
│  ├─ ErrorHighlighter                                       │
│  └─ RawRenderer                                            │
├─────────────────────────────────────────────────────────────┤
│  外部插件 (External Plugins)                                │
│  ├─ 用户自定义插件                                          │
│  ├─ 第三方插件                                              │
│  └─ 社区插件                                                │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件设计

#### 2.2.1 插件注册中心 (Plugin Registry)

```rust
// src/plugins/registry.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct PluginRegistry {
    parsers: Arc<RwLock<HashMap<String, Box<dyn LogParser + Send + Sync>>>>,
    renderers: Arc<RwLock<HashMap<String, Box<dyn LogRenderer + Send + Sync>>>>,
    filters: Arc<RwLock<HashMap<String, Box<dyn LogFilter + Send + Sync>>>>,
    exporters: Arc<RwLock<HashMap<String, Box<dyn LogExporter + Send + Sync>>>>,
    plugin_configs: Arc<RwLock<HashMap<String, PluginConfig>>>,
}

impl PluginRegistry {
    pub async fn register_parser(&self, name: String, parser: Box<dyn LogParser + Send + Sync>) -> Result<(), PluginError>;
    pub async fn register_renderer(&self, name: String, renderer: Box<dyn LogRenderer + Send + Sync>) -> Result<(), PluginError>;
    pub async fn get_parser(&self, name: &str) -> Option<Box<dyn LogParser + Send + Sync>>;
    pub async fn get_renderer(&self, name: &str) -> Option<Box<dyn LogRenderer + Send + Sync>>;
    pub async fn list_plugins(&self) -> Vec<PluginInfo>;
    pub async fn enable_plugin(&self, name: &str) -> Result<(), PluginError>;
    pub async fn disable_plugin(&self, name: &str) -> Result<(), PluginError>;
}
```

#### 2.2.2 插件配置系统

```rust
// src/plugins/config.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginConfig {
    pub name: String,
    pub version: String,
    pub enabled: bool,
    pub priority: i32,
    pub dependencies: Vec<String>,
    pub settings: HashMap<String, serde_json::Value>,
    pub conditions: Vec<PluginCondition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PluginCondition {
    FileExtension(String),
    ContentPattern(String),
    LogLevel(String),
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginManifest {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub plugin_type: PluginType,
    pub capabilities: Vec<String>,
    pub dependencies: Vec<String>,
    pub config_schema: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PluginType {
    Parser,
    Renderer,
    Filter,
    Exporter,
}
```

#### 2.2.3 插件接口定义

```rust
// src/plugins/traits.rs
use async_trait::async_trait;

#[async_trait]
pub trait LogParser: Send + Sync {
    async fn can_parse(&self, content: &str) -> bool;
    async fn parse(&self, content: &str, config: &PluginConfig) -> Result<ParseResult, PluginError>;
    fn get_name(&self) -> &str;
    fn get_version(&self) -> &str;
    fn get_capabilities(&self) -> Vec<String>;
}

#[async_trait]
pub trait LogRenderer: Send + Sync {
    async fn can_render(&self, content: &str) -> bool;
    async fn render(&self, content: &str, config: &PluginConfig) -> Result<RenderedBlock, PluginError>;
    fn get_name(&self) -> &str;
    fn get_version(&self) -> &str;
    fn get_supported_formats(&self) -> Vec<String>;
}

#[async_trait]
pub trait LogFilter: Send + Sync {
    async fn filter(&self, entries: &[LogEntry], config: &PluginConfig) -> Result<Vec<LogEntry>, PluginError>;
    fn get_name(&self) -> &str;
    fn get_version(&self) -> &str;
    fn get_filter_criteria(&self) -> Vec<String>;
}

#[async_trait]
pub trait LogExporter: Send + Sync {
    async fn export(&self, entries: &[LogEntry], format: &str, config: &PluginConfig) -> Result<Vec<u8>, PluginError>;
    fn get_name(&self) -> &str;
    fn get_version(&self) -> &str;
    fn get_supported_formats(&self) -> Vec<String>;
}
```

### 2.3 插件发现和加载机制

#### 2.3.1 插件目录结构

```
plugins/
├── builtin/                    # 内置插件
│   ├── mybatis/
│   │   ├── Cargo.toml
│   │   ├── src/
│   │   │   └── lib.rs
│   │   └── plugin.toml
│   ├── json_repair/
│   │   ├── Cargo.toml
│   │   ├── src/
│   │   │   └── lib.rs
│   │   └── plugin.toml
│   └── error_highlighter/
│       ├── Cargo.toml
│       ├── src/
│       │   └── lib.rs
│       └── plugin.toml
├── external/                   # 外部插件
│   ├── nginx_parser/
│   │   ├── Cargo.toml
│   │   ├── src/
│   │   │   └── lib.rs
│   │   └── plugin.toml
│   └── kubernetes_parser/
│       ├── Cargo.toml
│       ├── src/
│       │   └── lib.rs
│       └── plugin.toml
└── config/
    ├── plugins.toml           # 插件配置文件
    └── user_plugins.toml      # 用户自定义插件配置
```

#### 2.3.2 插件清单文件 (plugin.toml)

```toml
# plugins/builtin/mybatis/plugin.toml
[plugin]
name = "mybatis_parser"
version = "1.0.0"
description = "MyBatis SQL 参数还原插件"
author = "LogWhisper Team"
plugin_type = "Parser"

[capabilities]
supported_formats = ["log", "txt"]
supported_patterns = ["Preparing:", "Parameters:"]

[dependencies]
regex = "1.0"
serde = "1.0"

[config]
enabled = true
priority = 100
auto_detect = true

[config.settings]
merge_multiline = true
preserve_formatting = true
highlight_sql_keywords = true

[config.conditions]
- type = "ContentPattern"
  pattern = "Preparing:"
- type = "ContentPattern" 
  pattern = "Parameters:"
```

#### 2.3.3 插件加载器

```rust
// src/plugins/loader.rs
use std::path::Path;
use tokio::fs;

pub struct PluginLoader {
    registry: Arc<PluginRegistry>,
    plugin_dirs: Vec<PathBuf>,
}

impl PluginLoader {
    pub async fn load_all_plugins(&self) -> Result<(), PluginError> {
        // 1. 扫描插件目录
        let plugin_manifests = self.scan_plugin_directories().await?;
        
        // 2. 解析插件依赖
        let dependency_graph = self.resolve_dependencies(&plugin_manifests).await?;
        
        // 3. 按依赖顺序加载插件
        for plugin_name in dependency_graph.topological_sort() {
            self.load_plugin(&plugin_name).await?;
        }
        
        Ok(())
    }
    
    async fn load_plugin(&self, plugin_name: &str) -> Result<(), PluginError> {
        // 1. 读取插件清单
        let manifest = self.read_plugin_manifest(plugin_name).await?;
        
        // 2. 验证插件兼容性
        self.validate_plugin_compatibility(&manifest).await?;
        
        // 3. 动态加载插件
        let plugin_instance = self.instantiate_plugin(&manifest).await?;
        
        // 4. 注册到注册中心
        self.register_plugin_instance(&manifest, plugin_instance).await?;
        
        Ok(())
    }
}
```

### 2.4 插件执行引擎

#### 2.4.1 插件执行器

```rust
// src/plugins/executor.rs
pub struct PluginExecutor {
    registry: Arc<PluginRegistry>,
    config_manager: Arc<ConfigManager>,
}

impl PluginExecutor {
    pub async fn execute_parsers(&self, content: &str) -> Result<Vec<ParseResult>, PluginError> {
        let enabled_parsers = self.get_enabled_parsers().await?;
        let mut results = Vec::new();
        
        for parser in enabled_parsers {
            if parser.can_parse(content).await {
                let config = self.get_plugin_config(&parser.get_name()).await?;
                match parser.parse(content, &config).await {
                    Ok(result) => results.push(result),
                    Err(e) => log::warn!("Parser {} failed: {}", parser.get_name(), e),
                }
            }
        }
        
        Ok(results)
    }
    
    pub async fn execute_renderers(&self, content: &str, format: &str) -> Result<Vec<RenderedBlock>, PluginError> {
        let enabled_renderers = self.get_enabled_renderers().await?;
        let mut results = Vec::new();
        
        for renderer in enabled_renderers {
            if renderer.can_render(content).await {
                let config = self.get_plugin_config(&renderer.get_name()).await?;
                match renderer.render(content, &config).await {
                    Ok(block) => results.push(block),
                    Err(e) => log::warn!("Renderer {} failed: {}", renderer.get_name(), e),
                }
            }
        }
        
        Ok(results)
    }
}
```

#### 2.4.2 插件链式处理

```rust
// src/plugins/pipeline.rs
pub struct PluginPipeline {
    stages: Vec<PipelineStage>,
}

pub enum PipelineStage {
    Parser(String),
    Filter(String),
    Renderer(String),
    Exporter(String),
}

impl PluginPipeline {
    pub async fn execute(&self, input: &str) -> Result<PipelineResult, PluginError> {
        let mut current_data = input.to_string();
        let mut results = Vec::new();
        
        for stage in &self.stages {
            match stage {
                PipelineStage::Parser(name) => {
                    let parser = self.get_parser(name).await?;
                    let parse_results = parser.parse(&current_data, &self.get_config(name)).await?;
                    results.extend(parse_results);
                },
                PipelineStage::Filter(name) => {
                    let filter = self.get_filter(name).await?;
                    let filtered_entries = filter.filter(&results, &self.get_config(name)).await?;
                    results = filtered_entries;
                },
                PipelineStage::Renderer(name) => {
                    let renderer = self.get_renderer(name).await?;
                    for entry in &results {
                        let rendered = renderer.render(&entry.content, &self.get_config(name)).await?;
                        entry.rendered_blocks.push(rendered);
                    }
                },
                PipelineStage::Exporter(name) => {
                    let exporter = self.get_exporter(name).await?;
                    let exported_data = exporter.export(&results, "json", &self.get_config(name)).await?;
                    // 处理导出结果
                }
            }
        }
        
        Ok(PipelineResult { results, metadata: self.get_metadata() })
    }
}
```

### 2.5 插件开发接口

#### 2.5.1 插件开发模板

```rust
// plugins/external/nginx_parser/src/lib.rs
use log_whisper_plugin_sdk::*;
use serde_json::Value;

pub struct NginxParser {
    name: String,
    version: String,
}

impl NginxParser {
    pub fn new() -> Self {
        Self {
            name: "nginx_parser".to_string(),
            version: "1.0.0".to_string(),
        }
    }
}

#[async_trait]
impl LogParser for NginxParser {
    async fn can_parse(&self, content: &str) -> bool {
        content.contains("nginx") || content.contains("access.log")
    }
    
    async fn parse(&self, content: &str, config: &PluginConfig) -> Result<ParseResult, PluginError> {
        // 解析 Nginx 日志逻辑
        let entries = self.parse_nginx_log(content).await?;
        
        Ok(ParseResult {
            entries,
            metadata: ParseMetadata {
                parser_name: self.name.clone(),
                parser_version: self.version.clone(),
                parse_time_ms: 0, // 实际计算
                confidence: 0.95,
            }
        })
    }
    
    fn get_name(&self) -> &str {
        &self.name
    }
    
    fn get_version(&self) -> &str {
        &self.version
    }
    
    fn get_capabilities(&self) -> Vec<String> {
        vec![
            "nginx_access_log".to_string(),
            "nginx_error_log".to_string(),
            "nginx_combined_log".to_string(),
        ]
    }
}

// 插件入口点
#[no_mangle]
pub extern "C" fn create_parser() -> *mut dyn LogParser {
    Box::into_raw(Box::new(NginxParser::new()))
}
```

#### 2.5.2 插件SDK

```rust
// log-whisper-plugin-sdk/src/lib.rs
pub mod traits;
pub mod types;
pub mod errors;
pub mod macros;

pub use traits::*;
pub use types::*;
pub use errors::*;

// 便捷宏
#[macro_export]
macro_rules! plugin_main {
    ($parser_type:ty) => {
        #[no_mangle]
        pub extern "C" fn create_plugin() -> *mut dyn LogParser {
            Box::into_raw(Box::new(<$parser_type>::new()))
        }
    };
}

// 使用示例
plugin_main!(NginxParser);
```

### 2.6 配置管理系统

#### 2.6.1 插件配置文件

```toml
# config/plugins.toml
[global]
plugin_directory = "plugins"
auto_discovery = true
hot_reload = false

[plugins.mybatis_parser]
enabled = true
priority = 100
auto_detect = true
settings = { merge_multiline = true, preserve_formatting = true }

[plugins.json_repair]
enabled = true
priority = 90
auto_detect = true
settings = { pretty_print = true, validate_json = true }

[plugins.error_highlighter]
enabled = true
priority = 80
auto_detect = true
settings = { highlight_keywords = ["ERROR", "WARN", "Exception"] }

[plugins.nginx_parser]
enabled = false
priority = 50
auto_detect = false
settings = { parse_combined_log = true, extract_geoip = false }
```

#### 2.6.2 动态配置更新

```rust
// src/plugins/config_manager.rs
pub struct ConfigManager {
    config_path: PathBuf,
    watcher: Option<notify::RecommendedWatcher>,
    subscribers: Vec<Box<dyn ConfigSubscriber>>,
}

impl ConfigManager {
    pub async fn watch_config_changes(&mut self) -> Result<(), PluginError> {
        let mut watcher = notify::RecommendedWatcher::new(
            move |res| match res {
                Ok(event) => {
                    if event.kind.is_modify() {
                        self.reload_config().await;
                    }
                },
                Err(e) => log::error!("Config watcher error: {}", e),
            }
        )?;
        
        watcher.watch(&self.config_path, notify::RecursiveMode::NonRecursive)?;
        self.watcher = Some(watcher);
        
        Ok(())
    }
    
    pub async fn reload_config(&self) -> Result<(), PluginError> {
        let new_config = self.load_config().await?;
        self.notify_subscribers(new_config).await;
        Ok(())
    }
}
```

## 3. 实施计划

### 3.1 第一阶段：核心架构
- [ ] 实现插件注册中心
- [ ] 定义插件接口和trait
- [ ] 实现插件配置系统
- [ ] 迁移现有插件到新架构

### 3.2 第二阶段：插件管理
- [ ] 实现插件发现和加载机制
- [ ] 实现插件执行引擎
- [ ] 实现插件链式处理
- [ ] 添加插件生命周期管理

### 3.3 第三阶段：扩展功能
- [ ] 实现插件SDK
- [ ] 实现动态配置更新
- [ ] 实现插件热重载
- [ ] 添加插件性能监控

### 3.4 第四阶段：生态建设
- [ ] 建立插件开发文档
- [ ] 实现插件市场
- [ ] 建立插件认证机制
- [ ] 社区插件管理

## 4. 预期效果

### 4.1 开发效率提升
- **插件开发时间减少70%**：通过SDK和模板
- **配置管理效率提升80%**：通过可视化配置界面
- **调试效率提升60%**：通过插件隔离和日志

### 4.2 系统扩展性提升
- **支持无限插件扩展**：通过动态加载机制
- **插件间解耦**：通过标准接口和依赖管理
- **配置灵活性**：通过动态配置和条件执行

### 4.3 用户体验提升
- **插件市场**：用户可轻松安装第三方插件
- **个性化配置**：用户可自定义插件行为
- **性能优化**：通过插件优先级和条件执行

---

**文档版本**：v1.0  
**创建日期**：2024年1月  
**最后更新**：2024年1月
