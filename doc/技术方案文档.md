# LogWhisper æŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£

## 1. æŠ€æœ¯æ¶æ„æ¦‚è¿°

### 1.1 æ•´ä½“æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LogWhisper æŠ€æœ¯æ¶æ„                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‰ç«¯å±‚ (Tauri WebView)                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  HTML + CSS + JavaScript                               â”‚ â”‚
â”‚  â”‚  â”œâ”€ åŒæ å¸ƒå±€ç•Œé¢                                        â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ–‡ä»¶æ‹–æ‹½å¤„ç†                                        â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ’ä»¶åˆ‡æ¢æ§åˆ¶                                        â”‚ â”‚
â”‚  â”‚  â””â”€ ç”¨æˆ·äº¤äº’å“åº”                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Tauri Bridge (IPC é€šä¿¡å±‚)                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  invoke() è°ƒç”¨                                          â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ–‡ä»¶è¯»å–                                            â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ—¥å¿—è§£æ                                            â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ’ä»¶åˆ‡æ¢                                            â”‚ â”‚
â”‚  â”‚  â””â”€ ç»“æœè¿”å›                                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åç«¯å±‚ (Rust Core)                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æ—¥å¿—è§£æå¼•æ“                                           â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ–‡ä»¶è¯»å–æ¨¡å—                                        â”‚ â”‚
â”‚  â”‚  â”œâ”€ æ’ä»¶åŒ–è§£æå™¨                                        â”‚ â”‚
â”‚  â”‚  â”œâ”€ ç»“æœæ¸²æŸ“å¼•æ“                                        â”‚ â”‚
â”‚  â”‚  â””â”€ åå°å¤„ç†çº¿ç¨‹                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŠ€æœ¯é€‰å‹è¯´æ˜

| æŠ€æœ¯æ ˆ | é€‰æ‹©æ–¹æ¡ˆ | ç†ç”± |
|--------|----------|------|
| **æ ¸å¿ƒè¯­è¨€** | Rust | å†…å­˜å®‰å…¨ã€é«˜æ€§èƒ½ã€ç¼–è¯‘ä¸ºåŸç”Ÿå¯æ‰§è¡Œæ–‡ä»¶ |
| **æ¡Œé¢æ¡†æ¶** | Tauri 1.6+ | è½»é‡çº§ã€å®‰å…¨æ€§é«˜ã€Rustä¼˜å…ˆã€ä½“ç§¯å° |
| **å‰ç«¯æŠ€æœ¯** | Vanilla HTML + JS + Tailwind CSS | æ— éœ€æ„å»ºå·¥å…·ã€ä»£ç ç®€æ´ã€å¿«é€Ÿå¼€å‘ |
| **JSONå¤„ç†** | serde_json | Rustå®˜æ–¹æ¨èã€é«˜æ€§èƒ½ã€ç±»å‹å®‰å…¨ |
| **æ­£åˆ™å¼•æ“** | regex crate | é«˜æ€§èƒ½ã€Unicodeæ”¯æŒã€åŠŸèƒ½å®Œæ•´ |
| **æ—¶é—´è§£æ** | chrono | åŠŸèƒ½ä¸°å¯Œã€æ€§èƒ½ä¼˜ç§€ã€ç¤¾åŒºæ´»è·ƒ |
| **æ‰“åŒ…å·¥å…·** | tauri build | å®˜æ–¹å·¥å…·ã€æ”¯æŒå¤šå¹³å°ã€é…ç½®ç®€å• |

## 2. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 2.1 é¡¹ç›®ç»“æ„

```
log-whisper/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs                 # åº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ lib.rs                  # åº“å…¥å£
â”‚   â”œâ”€â”€ models/                 # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ log_entry.rs        # æ—¥å¿—æ¡ç›®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ rendered_block.rs   # æ¸²æŸ“å—æ¨¡å‹
â”‚   â”‚   â””â”€â”€ plugin_config.rs    # æ’ä»¶é…ç½®æ¨¡å‹
â”‚   â”œâ”€â”€ plugins/                # æ’ä»¶ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ trait.rs            # LogRenderer traitå®šä¹‰
â”‚   â”‚   â”œâ”€â”€ mybatis.rs          # MyBatisè§£ææ’ä»¶
â”‚   â”‚   â”œâ”€â”€ json_repair.rs      # JSONä¿®å¤æ’ä»¶
â”‚   â”‚   â”œâ”€â”€ error_highlighter.rs # é”™è¯¯é«˜äº®æ’ä»¶
â”‚   â”‚   â””â”€â”€ raw.rs              # åŸå§‹æ–‡æœ¬æ’ä»¶
â”‚   â”œâ”€â”€ parser/                 # è§£æå¼•æ“
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ log_parser.rs       # ä¸»è§£æå™¨
â”‚   â”‚   â”œâ”€â”€ file_reader.rs      # æ–‡ä»¶è¯»å–å™¨
â”‚   â”‚   â””â”€â”€ renderer.rs         # æ¸²æŸ“å¼•æ“
â”‚   â”œâ”€â”€ tauri/                  # Taurié›†æˆ
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ commands.rs         # Tauriå‘½ä»¤å®šä¹‰
â”‚   â”‚   â””â”€â”€ handlers.rs          # äº‹ä»¶å¤„ç†å™¨
â”‚   â””â”€â”€ utils/                  # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ file_utils.rs       # æ–‡ä»¶æ“ä½œå·¥å…·
â”‚       â””â”€â”€ string_utils.rs     # å­—ç¬¦ä¸²å¤„ç†å·¥å…·
â”œâ”€â”€ src-tauri/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ main.rs             # Tauriåç«¯å…¥å£
â”‚   â”œâ”€â”€ Cargo.toml              # Rustä¾èµ–é…ç½®
â”‚   â””â”€â”€ tauri.conf.json         # Taurié…ç½®æ–‡ä»¶
â”œâ”€â”€ src/                        # å‰ç«¯æºç 
â”‚   â”œâ”€â”€ index.html              # ä¸»é¡µé¢
â”‚   â”œâ”€â”€ style.css               # æ ·å¼æ–‡ä»¶
â”‚   â””â”€â”€ main.js                  # å‰ç«¯é€»è¾‘
â”œâ”€â”€ Cargo.toml                  # é¡¹ç›®é…ç½®
â””â”€â”€ README.md                   # é¡¹ç›®è¯´æ˜
```

### 2.2 æ ¸å¿ƒæ•°æ®ç»“æ„

#### 2.2.1 æ—¥å¿—æ¡ç›®æ¨¡å‹

```rust
// src/models/log_entry.rs
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    pub line_number: usize,
    pub timestamp: Option<DateTime<Utc>>,
    pub level: LogLevel,
    pub content: String,
    pub raw_line: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsedLogEntry {
    pub original: LogEntry,
    pub rendered_blocks: Vec<RenderedBlock>,
    pub is_error: bool,
    pub is_warning: bool,
}
```

#### 2.2.2 æ¸²æŸ“å—æ¨¡å‹

```rust
// src/models/rendered_block.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderedBlock {
    pub id: String,
    pub block_type: BlockType,
    pub title: String,
    pub content: String,
    pub formatted_content: String,
    pub is_copyable: bool,
    pub metadata: BlockMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BlockType {
    Sql,
    Json,
    Error,
    Warning,
    Info,
    Raw,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub line_start: usize,
    pub line_end: usize,
    pub char_start: usize,
    pub char_end: usize,
    pub confidence: f32, // 0.0 - 1.0
}
```

### 2.3 æ’ä»¶ç³»ç»Ÿè®¾è®¡

#### 2.3.1 æ’ä»¶Traitå®šä¹‰

```rust
// src/plugins/trait.rs
use crate::models::{LogEntry, RenderedBlock};

pub trait LogRenderer: Send + Sync {
    /// æ£€æŸ¥æ˜¯å¦å¯ä»¥å¤„ç†è¯¥æ—¥å¿—æ¡ç›®
    fn can_handle(&self, entry: &LogEntry) -> bool;
    
    /// å¤„ç†æ—¥å¿—æ¡ç›®ï¼Œè¿”å›æ¸²æŸ“å—
    fn render(&self, entry: &LogEntry) -> Vec<RenderedBlock>;
    
    /// è·å–æ’ä»¶åç§°
    fn name(&self) -> &str;
    
    /// è·å–æ’ä»¶æè¿°
    fn description(&self) -> &str;
    
    /// è·å–æ’ä»¶ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
    fn priority(&self) -> u32;
}
```

#### 2.3.2 MyBatisæ’ä»¶å®ç°

```rust
// src/plugins/mybatis.rs
use regex::Regex;
use crate::plugins::trait::LogRenderer;
use crate::models::{LogEntry, RenderedBlock, BlockType, BlockMetadata};

pub struct MyBatisRenderer {
    preparing_regex: Regex,
    parameters_regex: Regex,
    state: MyBatisState,
}

struct MyBatisState {
    current_sql: Option<String>,
    current_params: Option<Vec<String>>,
}

impl LogRenderer for MyBatisRenderer {
    fn can_handle(&self, entry: &LogEntry) -> bool {
        self.preparing_regex.is_match(&entry.content) || 
        self.parameters_regex.is_match(&entry.content)
    }
    
    fn render(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        if self.preparing_regex.is_match(&entry.content) {
            self.handle_preparing(entry)
        } else if self.parameters_regex.is_match(&entry.content) {
            self.handle_parameters(entry)
        } else {
            vec![]
        }
    }
    
    fn name(&self) -> &str {
        "MyBatis SQL Parser"
    }
    
    fn description(&self) -> &str {
        "è§£æMyBatisæ—¥å¿—ä¸­çš„SQLè¯­å¥å’Œå‚æ•°"
    }
    
    fn priority(&self) -> u32 {
        10
    }
}

impl MyBatisRenderer {
    fn handle_preparing(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        // æå–SQLè¯­å¥
        if let Some(captures) = self.preparing_regex.captures(&entry.content) {
            if let Some(sql) = captures.get(1) {
                return vec![RenderedBlock {
                    id: format!("sql_{}", entry.line_number),
                    block_type: BlockType::Sql,
                    title: "SQL æŸ¥è¯¢".to_string(),
                    content: sql.as_str().to_string(),
                    formatted_content: self.format_sql(sql.as_str()),
                    is_copyable: true,
                    metadata: BlockMetadata {
                        line_start: entry.line_number,
                        line_end: entry.line_number,
                        char_start: 0,
                        char_end: entry.content.len(),
                        confidence: 0.9,
                    },
                }];
            }
        }
        vec![]
    }
    
    fn handle_parameters(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        // å¤„ç†å‚æ•°å¹¶åˆå¹¶SQL
        if let Some(captures) = self.parameters_regex.captures(&entry.content) {
            if let Some(params) = captures.get(1) {
                return vec![RenderedBlock {
                    id: format!("params_{}", entry.line_number),
                    block_type: BlockType::Sql,
                    title: "SQL å‚æ•°".to_string(),
                    content: params.as_str().to_string(),
                    formatted_content: self.format_parameters(params.as_str()),
                    is_copyable: true,
                    metadata: BlockMetadata {
                        line_start: entry.line_number,
                        line_end: entry.line_number,
                        char_start: 0,
                        char_end: entry.content.len(),
                        confidence: 0.8,
                    },
                }];
            }
        }
        vec![]
    }
    
    fn format_sql(&self, sql: &str) -> String {
        // SQLæ ¼å¼åŒ–é€»è¾‘
        sql.to_string()
    }
    
    fn format_parameters(&self, params: &str) -> String {
        // å‚æ•°æ ¼å¼åŒ–é€»è¾‘
        params.to_string()
    }
}
```

#### 2.3.3 JSONä¿®å¤æ’ä»¶å®ç°

```rust
// src/plugins/json_repair.rs
use serde_json::Value;
use crate::plugins::trait::LogRenderer;
use crate::models::{LogEntry, RenderedBlock, BlockType, BlockMetadata};

pub struct JsonRepairRenderer {
    json_regex: Regex,
}

impl LogRenderer for JsonRepairRenderer {
    fn can_handle(&self, entry: &LogEntry) -> bool {
        self.json_regex.is_match(&entry.content)
    }
    
    fn render(&self, entry: &LogEntry) -> Vec<RenderedBlock> {
        if let Some(json_str) = self.extract_json(&entry.content) {
            if let Ok(repaired_json) = self.repair_json(json_str) {
                return vec![RenderedBlock {
                    id: format!("json_{}", entry.line_number),
                    block_type: BlockType::Json,
                    title: "JSON æ•°æ®".to_string(),
                    content: json_str.to_string(),
                    formatted_content: self.format_json(&repaired_json),
                    is_copyable: true,
                    metadata: BlockMetadata {
                        line_start: entry.line_number,
                        line_end: entry.line_number,
                        char_start: 0,
                        char_end: entry.content.len(),
                        confidence: 0.7,
                    },
                }];
            }
        }
        vec![]
    }
    
    fn name(&self) -> &str {
        "JSON Repair"
    }
    
    fn description(&self) -> &str {
        "ä¿®å¤å’Œæ ¼å¼åŒ–JSONæ•°æ®"
    }
    
    fn priority(&self) -> u32 {
        20
    }
}

impl JsonRepairRenderer {
    fn extract_json(&self, content: &str) -> Option<&str> {
        // æå–JSONå­—ç¬¦ä¸²çš„é€»è¾‘
        self.json_regex.find(content).map(|m| m.as_str())
    }
    
    fn repair_json(&self, json_str: &str) -> Result<Value, serde_json::Error> {
        // JSONä¿®å¤é€»è¾‘
        let repaired = self.fix_common_issues(json_str);
        serde_json::from_str(&repaired)
    }
    
    fn fix_common_issues(&self, json_str: &str) -> String {
        let mut result = json_str.to_string();
        
        // ä¿®å¤ç¼ºå°‘é€—å·
        result = result.replace(r#"}{"#, r#"},{""#);
        
        // ä¿®å¤ç¼ºå°‘å¼•å·
        result = self.fix_missing_quotes(&result);
        
        // ä¿®å¤æœªé—­åˆæ‹¬å·
        result = self.fix_unclosed_brackets(&result);
        
        result
    }
    
    fn fix_missing_quotes(&self, json_str: &str) -> String {
        // å®ç°å¼•å·ä¿®å¤é€»è¾‘
        json_str.to_string()
    }
    
    fn fix_unclosed_brackets(&self, json_str: &str) -> String {
        // å®ç°æ‹¬å·ä¿®å¤é€»è¾‘
        json_str.to_string()
    }
    
    fn format_json(&self, value: &Value) -> String {
        serde_json::to_string_pretty(value).unwrap_or_default()
    }
}
```

### 2.4 è§£æå¼•æ“è®¾è®¡

#### 2.4.1 ä¸»è§£æå™¨

```rust
// src/parser/log_parser.rs
use std::sync::Arc;
use tokio::task;
use crate::models::{LogEntry, ParsedLogEntry};
use crate::plugins::trait::LogRenderer;
use crate::parser::file_reader::FileReader;
use crate::parser::renderer::Renderer;

pub struct LogParser {
    renderers: Vec<Arc<dyn LogRenderer>>,
    file_reader: FileReader,
    renderer: Renderer,
}

impl LogParser {
    pub fn new() -> Self {
        let renderers = Self::create_renderers();
        let file_reader = FileReader::new();
        let renderer = Renderer::new(renderers.clone());
        
        Self {
            renderers,
            file_reader,
            renderer,
        }
    }
    
    pub async fn parse_file(&self, file_path: &str) -> Result<Vec<ParsedLogEntry>, ParserError> {
        // å¼‚æ­¥è¯»å–æ–‡ä»¶
        let lines = self.file_reader.read_lines(file_path).await?;
        
        // è§£ææ—¥å¿—æ¡ç›®
        let log_entries = self.parse_lines(lines).await?;
        
        // æ¸²æŸ“ç»“æœ
        let parsed_entries = self.renderer.render_entries(log_entries).await?;
        
        Ok(parsed_entries)
    }
    
    async fn parse_lines(&self, lines: Vec<String>) -> Result<Vec<LogEntry>, ParserError> {
        let mut entries = Vec::new();
        
        for (index, line) in lines.iter().enumerate() {
            let entry = self.parse_line(index + 1, line)?;
            entries.push(entry);
        }
        
        Ok(entries)
    }
    
    fn parse_line(&self, line_number: usize, line: &str) -> Result<LogEntry, ParserError> {
        // è§£ææ—¶é—´æˆ³
        let timestamp = self.extract_timestamp(line);
        
        // è§£ææ—¥å¿—çº§åˆ«
        let level = self.extract_log_level(line);
        
        // æå–å†…å®¹
        let content = self.extract_content(line);
        
        Ok(LogEntry {
            line_number,
            timestamp,
            level,
            content,
            raw_line: line.to_string(),
        })
    }
    
    fn create_renderers() -> Vec<Arc<dyn LogRenderer>> {
        vec![
            Arc::new(MyBatisRenderer::new()),
            Arc::new(JsonRepairRenderer::new()),
            Arc::new(ErrorHighlighterRenderer::new()),
            Arc::new(RawRenderer::new()),
        ]
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ParserError {
    #[error("æ–‡ä»¶è¯»å–é”™è¯¯: {0}")]
    FileReadError(String),
    
    #[error("è§£æé”™è¯¯: {0}")]
    ParseError(String),
    
    #[error("æ¸²æŸ“é”™è¯¯: {0}")]
    RenderError(String),
}
```

#### 2.4.2 æ¸²æŸ“å¼•æ“

```rust
// src/parser/renderer.rs
use std::sync::Arc;
use crate::models::{LogEntry, ParsedLogEntry, RenderedBlock};
use crate::plugins::trait::LogRenderer;

pub struct Renderer {
    renderers: Vec<Arc<dyn LogRenderer>>,
}

impl Renderer {
    pub fn new(renderers: Vec<Arc<dyn LogRenderer>>) -> Self {
        Self { renderers }
    }
    
    pub async fn render_entries(&self, entries: Vec<LogEntry>) -> Result<Vec<ParsedLogEntry>, RenderError> {
        let mut parsed_entries = Vec::new();
        
        for entry in entries {
            let rendered_blocks = self.render_entry(&entry).await?;
            let is_error = self.is_error_entry(&entry);
            let is_warning = self.is_warning_entry(&entry);
            
            parsed_entries.push(ParsedLogEntry {
                original: entry,
                rendered_blocks,
                is_error,
                is_warning,
            });
        }
        
        Ok(parsed_entries)
    }
    
    async fn render_entry(&self, entry: &LogEntry) -> Result<Vec<RenderedBlock>, RenderError> {
        let mut all_blocks = Vec::new();
        
        // æŒ‰ä¼˜å…ˆçº§æ’åºæ¸²æŸ“å™¨
        let mut sorted_renderers = self.renderers.clone();
        sorted_renderers.sort_by_key(|r| r.priority());
        
        for renderer in sorted_renderers {
            if renderer.can_handle(entry) {
                let blocks = renderer.render(entry);
                all_blocks.extend(blocks);
            }
        }
        
        // å¦‚æœæ²¡æœ‰æ¸²æŸ“å™¨å¤„ç†ï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬
        if all_blocks.is_empty() {
            all_blocks.push(RenderedBlock {
                id: format!("raw_{}", entry.line_number),
                block_type: BlockType::Raw,
                title: "åŸå§‹æ–‡æœ¬".to_string(),
                content: entry.content.clone(),
                formatted_content: entry.content.clone(),
                is_copyable: true,
                metadata: BlockMetadata {
                    line_start: entry.line_number,
                    line_end: entry.line_number,
                    char_start: 0,
                    char_end: entry.content.len(),
                    confidence: 1.0,
                },
            });
        }
        
        Ok(all_blocks)
    }
    
    fn is_error_entry(&self, entry: &LogEntry) -> bool {
        entry.level == LogLevel::Error || 
        entry.content.to_lowercase().contains("error") ||
        entry.content.to_lowercase().contains("exception")
    }
    
    fn is_warning_entry(&self, entry: &LogEntry) -> bool {
        entry.level == LogLevel::Warn || 
        entry.content.to_lowercase().contains("warn")
    }
}

#[derive(Debug, thiserror::Error)]
pub enum RenderError {
    #[error("æ¸²æŸ“å¤±è´¥: {0}")]
    RenderFailed(String),
}
```

## 3. Taurié›†æˆè®¾è®¡

### 3.1 Tauriå‘½ä»¤å®šä¹‰

```rust
// src/tauri/commands.rs
use tauri::State;
use serde::{Deserialize, Serialize};
use crate::parser::log_parser::LogParser;
use crate::models::ParsedLogEntry;

#[derive(Debug, Serialize, Deserialize)]
pub struct ParseFileRequest {
    pub file_path: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ParseFileResponse {
    pub success: bool,
    pub entries: Vec<ParsedLogEntry>,
    pub error: Option<String>,
}

#[tauri::command]
pub async fn parse_file(
    request: ParseFileRequest,
    parser: State<'_, LogParser>,
) -> Result<ParseFileResponse, String> {
    match parser.parse_file(&request.file_path).await {
        Ok(entries) => Ok(ParseFileResponse {
            success: true,
            entries,
            error: None,
        }),
        Err(e) => Ok(ParseFileResponse {
            success: false,
            entries: vec![],
            error: Some(e.to_string()),
        }),
    }
}

#[tauri::command]
pub async fn get_supported_formats() -> Vec<String> {
    vec![".log".to_string(), ".txt".to_string()]
}

#[tauri::command]
pub async fn get_available_plugins() -> Vec<String> {
    vec![
        "Auto".to_string(),
        "MyBatis".to_string(),
        "JSON".to_string(),
        "Raw".to_string(),
    ]
}
```

### 3.2 å‰ç«¯é›†æˆ

#### 3.2.1 HTMLç»“æ„

```html
<!-- src/index.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogWhisper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body class="bg-gray-50">
    <div id="app" class="h-screen flex flex-col">
        <!-- é¡¶éƒ¨å·¥å…·æ  -->
        <div class="bg-white shadow-sm border-b p-4">
            <div class="flex items-center space-x-4">
                <button id="openFileBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                    é€‰æ‹©æ–‡ä»¶
                </button>
                <div class="flex-1">
                    <input type="file" id="fileInput" accept=".log,.txt" class="hidden">
                </div>
                <select id="pluginSelect" class="border rounded px-3 py-2">
                    <option value="auto">Auto</option>
                    <option value="mybatis">MyBatis</option>
                    <option value="json">JSON</option>
                    <option value="raw">Raw</option>
                </select>
                <input type="text" id="searchInput" placeholder="æœç´¢æ—¥å¿—..." 
                       class="border rounded px-3 py-2 w-64">
            </div>
        </div>
        
        <!-- ä¸»å†…å®¹åŒºåŸŸ -->
        <div class="flex-1 flex">
            <!-- å·¦ä¾§ï¼šåŸå§‹æ—¥å¿— -->
            <div class="w-1/2 border-r bg-white">
                <div class="p-4 border-b bg-gray-50">
                    <h3 class="font-semibold">åŸå§‹æ—¥å¿—</h3>
                </div>
                <div id="originalLog" class="p-4 font-mono text-sm overflow-auto h-full">
                    <div class="text-gray-500 text-center py-8">
                        æ‹–æ‹½æ—¥å¿—æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»"é€‰æ‹©æ–‡ä»¶"
                    </div>
                </div>
            </div>
            
            <!-- å³ä¾§ï¼šè§£æç»“æœ -->
            <div class="w-1/2 bg-white">
                <div class="p-4 border-b bg-gray-50">
                    <h3 class="font-semibold">è§£æç»“æœ</h3>
                </div>
                <div id="parsedLog" class="p-4 overflow-auto h-full">
                    <div class="text-gray-500 text-center py-8">
                        é€‰æ‹©æ–‡ä»¶åå°†æ˜¾ç¤ºè§£æç»“æœ
                    </div>
                </div>
            </div>
        </div>
        
        <!-- åº•éƒ¨çŠ¶æ€æ  -->
        <div class="bg-gray-100 border-t px-4 py-2 text-sm text-gray-600">
            <span id="statusText">å°±ç»ª</span>
        </div>
    </div>
    
    <script src="main.js"></script>
</body>
</html>
```

#### 3.2.2 JavaScripté€»è¾‘

```javascript
// src/main.js
const { invoke } = window.__TAURI__.tauri;

class LogWhisperApp {
    constructor() {
        this.currentFile = null;
        this.currentEntries = [];
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.setupDragAndDrop();
    }
    
    setupEventListeners() {
        // æ–‡ä»¶é€‰æ‹©
        document.getElementById('openFileBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleFile(e.target.files[0]);
            }
        });
        
        // æ’ä»¶åˆ‡æ¢
        document.getElementById('pluginSelect').addEventListener('change', (e) => {
            this.switchPlugin(e.target.value);
        });
        
        // æœç´¢è¿‡æ»¤
        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.filterLogs(e.target.value);
        });
    }
    
    setupDragAndDrop() {
        const app = document.getElementById('app');
        
        app.addEventListener('dragover', (e) => {
            e.preventDefault();
            app.classList.add('bg-blue-50');
        });
        
        app.addEventListener('dragleave', (e) => {
            e.preventDefault();
            app.classList.remove('bg-blue-50');
        });
        
        app.addEventListener('drop', (e) => {
            e.preventDefault();
            app.classList.remove('bg-blue-50');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFile(files[0]);
            }
        });
    }
    
    async handleFile(file) {
        if (!this.isValidFile(file)) {
            this.showError('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼');
            return;
        }
        
        if (file.size > 50 * 1024 * 1024) {
            this.showError('æ–‡ä»¶è¿‡å¤§ï¼Œè¯·ä½¿ç”¨ä¸“ä¸šå·¥å…·');
            return;
        }
        
        this.showLoading('æ­£åœ¨è§£ææ–‡ä»¶...');
        
        try {
            const response = await invoke('parse_file', {
                request: {
                    filePath: file.path
                }
            });
            
            if (response.success) {
                this.currentFile = file;
                this.currentEntries = response.entries;
                this.renderResults();
                this.updateStatus(`å·²åŠ è½½ ${response.entries.length} è¡Œæ—¥å¿—`);
            } else {
                this.showError(response.error || 'è§£æå¤±è´¥');
            }
        } catch (error) {
            this.showError(`è§£æé”™è¯¯: ${error}`);
        }
    }
    
    isValidFile(file) {
        const validExtensions = ['.log', '.txt'];
        const fileName = file.name.toLowerCase();
        return validExtensions.some(ext => fileName.endsWith(ext));
    }
    
    renderResults() {
        this.renderOriginalLog();
        this.renderParsedLog();
    }
    
    renderOriginalLog() {
        const container = document.getElementById('originalLog');
        container.innerHTML = '';
        
        this.currentEntries.forEach(entry => {
            const div = document.createElement('div');
            div.className = `p-2 border-b ${this.getLogLevelClass(entry.original.level)}`;
            div.innerHTML = `
                <div class="text-xs text-gray-500">${entry.original.line_number}</div>
                <div class="font-mono">${this.escapeHtml(entry.original.content)}</div>
            `;
            container.appendChild(div);
        });
    }
    
    renderParsedLog() {
        const container = document.getElementById('parsedLog');
        container.innerHTML = '';
        
        this.currentEntries.forEach(entry => {
            if (entry.rendered_blocks.length === 0) return;
            
            const div = document.createElement('div');
            div.className = `p-4 border-b ${entry.is_error ? 'bg-red-50' : entry.is_warning ? 'bg-yellow-50' : ''}`;
            
            let html = `<div class="text-xs text-gray-500 mb-2">ç¬¬ ${entry.original.line_number} è¡Œ</div>`;
            
            entry.rendered_blocks.forEach(block => {
                html += this.renderBlock(block);
            });
            
            div.innerHTML = html;
            container.appendChild(div);
        });
    }
    
    renderBlock(block) {
        const blockClass = this.getBlockClass(block.block_type);
        const icon = this.getBlockIcon(block.block_type);
        
        return `
            <div class="mb-4 p-3 rounded border ${blockClass}">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center">
                        <span class="mr-2">${icon}</span>
                        <span class="font-semibold">${block.title}</span>
                    </div>
                    <button onclick="app.copyToClipboard('${block.id}')" 
                            class="text-blue-600 hover:text-blue-800 text-sm">
                        å¤åˆ¶
                    </button>
                </div>
                <pre class="bg-gray-100 p-2 rounded text-sm overflow-x-auto">${this.escapeHtml(block.formatted_content)}</pre>
            </div>
        `;
    }
    
    getBlockClass(blockType) {
        const classes = {
            'Sql': 'border-green-200 bg-green-50',
            'Json': 'border-blue-200 bg-blue-50',
            'Error': 'border-red-200 bg-red-50',
            'Warning': 'border-yellow-200 bg-yellow-50',
            'Info': 'border-gray-200 bg-gray-50',
            'Raw': 'border-gray-200 bg-gray-50'
        };
        return classes[blockType] || classes['Raw'];
    }
    
    getBlockIcon(blockType) {
        const icons = {
            'Sql': 'ğŸ”',
            'Json': 'ğŸ“„',
            'Error': 'âš ï¸',
            'Warning': 'âš ï¸',
            'Info': 'â„¹ï¸',
            'Raw': 'ğŸ“'
        };
        return icons[blockType] || icons['Raw'];
    }
    
    getLogLevelClass(level) {
        const classes = {
            'Error': 'bg-red-50 border-l-4 border-red-500',
            'Warn': 'bg-yellow-50 border-l-4 border-yellow-500',
            'Info': 'bg-blue-50 border-l-4 border-blue-500',
            'Debug': 'bg-gray-50 border-l-4 border-gray-500'
        };
        return classes[level] || classes['Debug'];
    }
    
    async copyToClipboard(blockId) {
        // å®ç°å¤åˆ¶åˆ°å‰ªè´´æ¿åŠŸèƒ½
        const block = this.findBlockById(blockId);
        if (block) {
            await navigator.clipboard.writeText(block.formatted_content);
            this.showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
        }
    }
    
    findBlockById(blockId) {
        for (const entry of this.currentEntries) {
            for (const block of entry.rendered_blocks) {
                if (block.id === blockId) {
                    return block;
                }
            }
        }
        return null;
    }
    
    switchPlugin(pluginName) {
        // å®ç°æ’ä»¶åˆ‡æ¢é€»è¾‘
        console.log('åˆ‡æ¢æ’ä»¶:', pluginName);
    }
    
    filterLogs(searchTerm) {
        // å®ç°æœç´¢è¿‡æ»¤é€»è¾‘
        console.log('æœç´¢:', searchTerm);
    }
    
    showLoading(message) {
        this.updateStatus(message);
    }
    
    showError(message) {
        this.updateStatus(`é”™è¯¯: ${message}`);
    }
    
    showToast(message) {
        // å®ç°Toastæç¤º
        console.log(message);
    }
    
    updateStatus(message) {
        document.getElementById('statusText').textContent = message;
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// åˆå§‹åŒ–åº”ç”¨
const app = new LogWhisperApp();
```

## 4. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 4.1 å†…å­˜ç®¡ç†

```rust
// æµå¼å¤„ç†å¤§æ–‡ä»¶
pub struct StreamingLogParser {
    chunk_size: usize,
    buffer: Vec<u8>,
}

impl StreamingLogParser {
    pub async fn parse_large_file(&mut self, file_path: &str) -> Result<(), ParserError> {
        let mut file = File::open(file_path).await?;
        let mut buffer = vec![0; self.chunk_size];
        
        loop {
            let bytes_read = file.read(&mut buffer).await?;
            if bytes_read == 0 {
                break;
            }
            
            // å¤„ç†å½“å‰å—
            self.process_chunk(&buffer[..bytes_read]).await?;
        }
        
        Ok(())
    }
}
```

### 4.2 å¼‚æ­¥å¤„ç†

```rust
// åå°è§£æä»»åŠ¡
pub async fn parse_file_async(file_path: String) -> Result<Vec<ParsedLogEntry>, ParserError> {
    tokio::task::spawn_blocking(move || {
        // åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡ŒCPUå¯†é›†å‹ä»»åŠ¡
        let parser = LogParser::new();
        parser.parse_file_sync(&file_path)
    }).await?
}
```

### 4.3 ç¼“å­˜ç­–ç•¥

```rust
// è§£æç»“æœç¼“å­˜
use std::collections::HashMap;
use std::sync::RwLock;

pub struct ParseCache {
    cache: RwLock<HashMap<String, Vec<ParsedLogEntry>>>,
    max_size: usize,
}

impl ParseCache {
    pub fn get(&self, file_path: &str) -> Option<Vec<ParsedLogEntry>> {
        self.cache.read().unwrap().get(file_path).cloned()
    }
    
    pub fn set(&self, file_path: String, entries: Vec<ParsedLogEntry>) {
        let mut cache = self.cache.write().unwrap();
        if cache.len() >= self.max_size {
            // ç®€å•çš„LRUç­–ç•¥
            cache.clear();
        }
        cache.insert(file_path, entries);
    }
}
```

## 5. æ‰“åŒ…å’Œåˆ†å‘

### 5.1 Taurié…ç½®

```json
// src-tauri/tauri.conf.json
{
  "build": {
    "beforeDevCommand": "",
    "beforeBuildCommand": "",
    "devPath": "../src",
    "distDir": "../src"
  },
  "package": {
    "productName": "LogWhisper",
    "version": "1.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "fs": {
        "all": true,
        "readFile": true,
        "writeFile": true,
        "readDir": true,
        "copyFile": true,
        "createDir": true,
        "removeDir": true,
        "removeFile": true,
        "renameFile": true,
        "exists": true
      },
      "path": {
        "all": true
      },
      "dialog": {
        "all": true,
        "open": true,
        "save": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.logwhisper.app",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
    "security": {
      "csp": null
    },
    "windows": [
      {
        "fullscreen": false,
        "resizable": true,
        "title": "LogWhisper",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600
      }
    ]
  }
}
```

### 5.2 æ„å»ºè„šæœ¬

```toml
# Cargo.toml
[package]
name = "log-whisper"
version = "1.0.0"
edition = "2021"

[dependencies]
tauri = { version = "1.6", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
regex = "1.0"
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
anyhow = "1.0"

[build-dependencies]
tauri-build = { version = "1.6", features = [] }
```

### 5.3 æ„å»ºå‘½ä»¤

```bash
# å¼€å‘æ¨¡å¼
cargo tauri dev

# ç”Ÿäº§æ„å»º
cargo tauri build

# ç”Ÿæˆå®‰è£…åŒ…
cargo tauri build --target x86_64-pc-windows-msvc
```

## 6. æµ‹è¯•ç­–ç•¥

### 6.1 å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_mybatis_parser() {
        let parser = MyBatisRenderer::new();
        let entry = LogEntry {
            line_number: 1,
            timestamp: None,
            level: LogLevel::Info,
            content: "Preparing: SELECT * FROM user WHERE id = ?".to_string(),
            raw_line: "Preparing: SELECT * FROM user WHERE id = ?".to_string(),
        };
        
        assert!(parser.can_handle(&entry));
        let blocks = parser.render(&entry);
        assert!(!blocks.is_empty());
        assert_eq!(blocks[0].block_type, BlockType::Sql);
    }
    
    #[test]
    fn test_json_repair() {
        let parser = JsonRepairRenderer::new();
        let entry = LogEntry {
            line_number: 1,
            timestamp: None,
            level: LogLevel::Info,
            content: r#"{"name":"å¼ ä¸‰","age":25}"#.to_string(),
            raw_line: r#"{"name":"å¼ ä¸‰","age":25}"#.to_string(),
        };
        
        assert!(parser.can_handle(&entry));
        let blocks = parser.render(&entry);
        assert!(!blocks.is_empty());
        assert_eq!(blocks[0].block_type, BlockType::Json);
    }
}
```

### 6.2 é›†æˆæµ‹è¯•

```rust
#[tokio::test]
async fn test_full_parse_workflow() {
    let parser = LogParser::new();
    let test_file = "test_data/sample.log";
    
    let result = parser.parse_file(test_file).await;
    assert!(result.is_ok());
    
    let entries = result.unwrap();
    assert!(!entries.is_empty());
    
    // éªŒè¯è§£æç»“æœ
    for entry in entries {
        assert!(!entry.rendered_blocks.is_empty());
    }
}
```

## 7. éƒ¨ç½²å’Œå‘å¸ƒ

### 7.1 ç‰ˆæœ¬ç®¡ç†

```toml
# Cargo.toml
[package]
name = "log-whisper"
version = "1.0.0"
authors = ["Your Name <your.email@example.com>"]
description = "è½»é‡çº§æ—¥å¿—åˆ†æå·¥å…·"
license = "MIT"
repository = "https://github.com/your-username/log-whisper"
```

### 7.2 å‘å¸ƒæµç¨‹

```bash
# 1. æ›´æ–°ç‰ˆæœ¬å·
cargo set-version 1.0.1

# 2. è¿è¡Œæµ‹è¯•
cargo test

# 3. æ„å»ºå‘å¸ƒç‰ˆæœ¬
cargo tauri build --target x86_64-pc-windows-msi

# 4. ç”Ÿæˆå‘å¸ƒè¯´æ˜
echo "## æ›´æ–°å†…å®¹" > CHANGELOG.md
echo "- ä¿®å¤JSONè§£æé—®é¢˜" >> CHANGELOG.md
echo "- ä¼˜åŒ–æ€§èƒ½" >> CHANGELOG.md

# 5. åˆ›å»ºGitæ ‡ç­¾
git tag v1.0.1
git push origin v1.0.1
```

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**åˆ›å»ºæ—¥æœŸ**ï¼š2024å¹´1æœˆ  
**æœ€åæ›´æ–°**ï¼š2024å¹´1æœˆ
